# Developer Documentation

Complete developer documentation for the Laravel + React Starter Kit application. This documentation is designed to help both human developers and coding agents understand and work with the system.

---

## Table of Contents

1. [Project Overview](#1-project-overview)
2. [Development Environment Setup](#2-development-environment-setup)
3. [Architecture & Project Structure](#3-architecture--project-structure)
4. [Core Features Documentation](#4-core-features-documentation)
5. [Database Schema](#5-database-schema)
6. [Development Guidelines](#6-development-guidelines)
7. [API & External Integrations](#7-api--external-integrations)
8. [Testing](#8-testing)
9. [Deployment & Production](#9-deployment--production)
10. [For Coding Agents](#10-for-coding-agents)

---

## 1. Project Overview

### 1.1 What is This Project?

This is a Laravel + React Starter Kit application that provides a modern, full-stack foundation for building SaaS applications. The application uses Inertia.js to create a single-page application experience while maintaining server-side routing and controllers.

### 1.2 Tech Stack

**Backend:**
- **Laravel 12** - PHP framework
- **PHP 8.4** - Runtime
- **PostgreSQL 18** - Primary database
- **Redis 8** - Caching and queues
- **Laravel Fortify** - Authentication scaffolding
- **Laravel Cashier** - Stripe subscription management
- **Laravel Socialite** - OAuth integration

**Frontend:**
- **React 19** - UI library
- **TypeScript** - Type safety
- **Inertia.js** - SPA framework
- **Vite** - Build tool and dev server
- **Tailwind CSS 4** - Utility-first CSS
- **shadcn/ui** - Component library (built on Radix UI)
- **Lucide React** - Icon library

**Development:**
- **Docker & Docker Compose** - Containerized development environment
- **Node.js 24** - Frontend tooling

### 1.3 Key Architectural Decisions

#### Domain-Driven Architecture
The entire codebase follows a **domain-driven folder structure** instead of technical layer grouping. This means:
- All code related to a business feature (Auth, Admin, Billing, etc.) lives together
- Backend and frontend code for the same domain are co-located conceptually
- Each domain is self-contained with its own controllers, models, services, and UI components

**Why?** This structure makes the codebase more maintainable, easier to understand, and simpler to extend. When working on a feature, all related code is in one place.

#### Inertia.js SPA Pattern
The application uses Inertia.js to create a single-page application experience:
- Server-side routing and controllers (Laravel)
- Client-side rendering and state management (React)
- No REST API needed for most operations
- Shared data between backend and frontend via Inertia props

**Why?** Combines the best of both worlds: Laravel's productivity with React's interactivity, without the complexity of a separate API layer.

#### Configuration-Driven Plans
Subscription plans are defined in `config/plans.php` rather than the database:
- Plans are version-controlled
- Easy to modify without migrations
- Type-safe access via config helpers

### 1.4 Design System

The UI follows the **OpenAI Platform Dashboard** aesthetic:
- Clean, minimal design
- Subtle borders and shadows
- Comfortable whitespace
- Clear visual hierarchy

**Component Library:** shadcn/ui (built on Radix UI primitives)
- Accessible by default
- Customizable via Tailwind CSS
- Consistent design tokens

**Styling:** Tailwind CSS utility classes
- Consistent spacing scale
- Design tokens for colors, typography, etc.
- Responsive design patterns

**Icons:** Lucide React
- Consistent line-based icon style
- Standardized sizes (16-20px typically)

See `ui-guidelines.md` for detailed UI/UX guidelines.

---

## 2. Development Environment Setup

### 2.1 Prerequisites

- Docker and Docker Compose installed
- Git

### 2.2 Initial Setup

1. **Clone the repository** (if applicable)

2. **Copy environment file:**
   ```bash
   cp .env.example .env
   ```

3. **Start Docker environment:**
   ```bash
   docker compose up -d
   ```

4. **Install PHP dependencies:**
   ```bash
   docker compose exec app composer install
   ```

5. **Generate application key:**
   ```bash
   docker compose exec app php artisan key:generate
   ```

6. **Install Node.js dependencies:**
   ```bash
   docker compose exec app npm install
   ```

7. **Run database migrations:**
   ```bash
   docker compose exec app php artisan migrate
   ```

8. **Create admin user (optional):**
   ```bash
   docker compose exec app php artisan db:seed --class=AdminUserSeeder
   ```

### 2.3 Environment Configuration

#### Required Environment Variables

**Application:**
```env
APP_NAME="Your App Name"
APP_ENV=local
APP_KEY=  # Generated by artisan key:generate
APP_DEBUG=true
APP_URL=http://localhost:8000
```

**Database:**
```env
DB_CONNECTION=pgsql
DB_HOST=postgres
DB_PORT=5432
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=laravel
```

**Redis:**
```env
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379
```

**Mail (for Magic Link):**
```env
MAIL_MAILER=smtp
MAIL_HOST=mailpit
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"
```

#### Google OAuth Configuration

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project or select existing
3. Enable Google+ API
4. Create OAuth 2.0 credentials (Web application)
5. Add authorized redirect URI: `http://localhost:8000/auth/google/callback`
6. Add to `.env`:
   ```env
   GOOGLE_CLIENT_ID=your-client-id
   GOOGLE_CLIENT_SECRET=your-client-secret
   GOOGLE_REDIRECT_URI=http://localhost:8000/auth/google/callback
   ```

#### Stripe Configuration

1. Create a Stripe account at [stripe.com](https://stripe.com)
2. Get API keys from Dashboard → Developers → API keys
3. Add to `.env`:
   ```env
   STRIPE_KEY=pk_test_...
   STRIPE_SECRET=sk_test_...
   STRIPE_WEBHOOK_SECRET=whsec_...  # For webhook verification
   ```

4. Create Stripe products and prices for:
   - Subscription plans (Pro, Business)
   - Credit packs (50, 100, 500 credits)
5. Add price IDs to `.env`:
   ```env
   STRIPE_PRICE_PRO_MONTHLY=price_...
   STRIPE_PRICE_BUSINESS_MONTHLY=price_...
   STRIPE_PRICE_CREDITS_50=price_...
   STRIPE_PRICE_CREDITS_100=price_...
   STRIPE_PRICE_CREDITS_500=price_...
   ```

### 2.4 Docker Services

The Docker environment includes:

- **app** - PHP 8.4 + Node.js 24 container
  - Laravel application
  - Vite dev server
  - Supervisor manages both processes
- **postgres** - PostgreSQL 18 database
- **redis** - Redis 8 cache/queue

**Access:**
- Application: http://localhost:8000
- Vite dev server: http://localhost:5173 (hot reloading)

### 2.5 Common Development Commands

**Run Artisan commands:**
```bash
docker compose exec app php artisan <command>
```

**Run npm commands:**
```bash
docker compose exec app npm <command>
```

**View logs:**
```bash
docker compose logs -f app
```

**Stop environment:**
```bash
docker compose down
```

**Rebuild containers:**
```bash
docker compose up -d --build
```

**Run tests:**
```bash
docker compose exec app php artisan test
```

**Run migrations:**
```bash
docker compose exec app php artisan migrate
```

**Run seeders:**
```bash
docker compose exec app php artisan db:seed
```

**Access database:**
```bash
docker compose exec postgres psql -U laravel -d laravel
```

---

## 3. Architecture & Project Structure

### 3.1 Domain-Driven Architecture

The project follows a **domain-driven folder structure**. Each business domain contains all related code (backend + frontend) in one place.

#### Core Principle
> Everything related to one feature must live in its corresponding domain folder.

#### Benefits
- **Maintainability:** All code for a feature is in one place
- **Clarity:** Easy to understand what code belongs to which feature
- **Scalability:** Easy to add new domains without affecting others
- **Onboarding:** New developers can understand the system by domain

### 3.2 Backend Structure (`app/Domain/`)

```
app/Domain/
├── Admin/              # Admin panel functionality
│   ├── Actions/        # Single-purpose action classes
│   ├── Controllers/    # HTTP controllers
│   ├── Middleware/     # Domain-specific middleware
│   ├── Models/         # Domain models (if any)
│   └── Requests/       # Form request validation
│
├── Auth/               # Authentication system
│   ├── Actions/        # Auth actions (SendMagicLink, VerifyMagicLink, etc.)
│   ├── Controllers/    # GoogleOAuthController, MagicLinkController
│   ├── Models/         # MagicLinkToken model
│   └── Requests/       # Auth form requests
│
├── Billing/            # Billing, subscriptions, credits
│   ├── Actions/        # Billing actions
│   ├── Controllers/    # BillingController, CheckoutController, etc.
│   ├── Models/         # CreditTransaction model
│   ├── Services/      # PlanService, CreditService, FeatureGateService
│   ├── Traits/         # HasCredits, HasSubscription
│   └── Requests/       # Billing form requests
│
├── Settings/           # User settings
│   ├── Actions/        # Settings actions
│   ├── Controllers/    # ProfileController, etc.
│   └── Requests/       # Settings form requests
│
├── Teams/              # Teams/Workspaces (future)
│   └── ...
│
└── Users/              # User management
    ├── Models/         # User model
    └── ...
```

#### Domain Structure Pattern

Each domain typically contains:

- **Controllers/** - HTTP request handlers
- **Actions/** - Single-purpose action classes (business logic)
- **Services/** - Reusable service classes
- **Models/** - Eloquent models specific to the domain
- **Requests/** - Form request validation classes
- **Middleware/** - Domain-specific middleware
- **Policies/** - Authorization policies (if needed)

### 3.3 Frontend Structure (`resources/js/domains/`)

```
resources/js/domains/
├── admin/              # Admin UI
│   ├── components/     # Admin-specific components
│   └── pages/          # Admin pages (index, users/index, users/show)
│
├── auth/               # Authentication UI
│   ├── components/     # GoogleLoginButton, MagicLinkForm
│   └── pages/          # login, register, etc.
│
├── billing/            # Billing UI
│   ├── components/     # PlanPaywall, CreditsPaywall, FeatureGate, CreditBalance
│   └── pages/          # Billing pages
│
├── settings/           # Settings UI
│   └── *.tsx           # Settings pages (profile, billing, appearance)
│
├── teams/              # Teams UI (future)
│   └── ...
│
└── users/              # User UI
    └── ...
```

#### Frontend Domain Pattern

- **pages/** - Inertia page components (route handlers)
- **components/** - Domain-specific React components

### 3.4 Shared/Global Components

Global UI components that are used across domains live in:
```
resources/js/components/
```

These are shared components like:
- Layout components (AppLayout, Sidebar, Header)
- Common UI elements (Button, Card, Dialog, etc.)
- Form components

### 3.5 Route Organization

Routes are organized by domain in separate files:

```
routes/
├── web.php          # Main routes (home, dashboard, auth)
├── admin.php        # Admin routes (loaded in web.php)
├── billing.php      # Billing routes (loaded in web.php)
└── settings.php     # Settings routes (loaded in web.php)
```

**Route Registration Pattern:**
```php
// In web.php
Route::middleware(['auth', 'verified', 'admin'])
    ->prefix('admin')
    ->name('admin.')
    ->group(base_path('routes/admin.php'));
```

### 3.6 Configuration Files

Domain-specific configuration:
- `config/plans.php` - Subscription plans and credit packs
- `config/fortify.php` - Fortify authentication configuration
- `config/inertia.php` - Inertia.js configuration

### 3.7 What Belongs Where?

#### ✅ DO: Place code in domains
- Feature-specific controllers → Domain/Controllers/
- Feature-specific models → Domain/Models/
- Feature-specific actions → Domain/Actions/
- Feature-specific UI → resources/js/domains/{domain}/

#### ❌ DON'T: Use global folders for domain code
- Don't put controllers in `app/Http/Controllers/`
- Don't put models in `app/Models/`
- Don't put pages in `resources/js/pages/` (use domains)

#### ✅ Exception: Global/shared code
- Service providers → `app/Providers/`
- Global middleware → `app/Http/Middleware/`
- Shared UI components → `resources/js/components/`
- Exception handlers → `app/Exceptions/`

---

## 4. Core Features Documentation

### 4.1 Authentication System

The application uses **two authentication methods only**:
1. **Google OAuth** - Social login via Google
2. **Magic Link** - Passwordless email link authentication

**Note:** Email+password authentication and 2FA are **disabled**.

#### 4.1.1 Authentication Flow

**Google OAuth:**
1. User clicks "Continue with Google"
2. Redirected to Google OAuth consent screen
3. Google redirects back to `/auth/google/callback`
4. System resolves/finds user by email
5. User is logged in and redirected to dashboard

**Magic Link:**
1. User enters email on login page
2. System generates time-limited, single-use token
3. Email sent with signed URL containing token
4. User clicks link in email
5. System verifies token and logs user in
6. Token is marked as used

#### 4.1.2 Auto-Create User Strategy

Both authentication methods use **auto-create strategy**:
- If user doesn't exist, a new account is created automatically
- Email is used as the unique identifier
- One email = one user account

#### 4.1.3 Key Files

**Backend:**
- `app/Domain/Auth/Controllers/GoogleOAuthController.php` - OAuth flow
- `app/Domain/Auth/Controllers/MagicLinkController.php` - Magic link handling
- `app/Domain/Auth/Actions/ResolveUserFromGoogle.php` - User resolution from Google
- `app/Domain/Auth/Actions/SendMagicLink.php` - Magic link generation
- `app/Domain/Auth/Actions/VerifyMagicLink.php` - Token verification
- `app/Domain/Auth/Models/MagicLinkToken.php` - Token model

**Frontend:**
- `resources/js/domains/auth/pages/login.tsx` - Login page
- `resources/js/domains/auth/components/GoogleLoginButton.tsx` - OAuth button
- `resources/js/domains/auth/components/MagicLinkForm.tsx` - Magic link form

**Routes:**
- `GET /auth/google` - Initiate OAuth
- `GET /auth/google/callback` - OAuth callback
- `POST /auth/magic-link/request` - Request magic link
- `GET /auth/magic-link/verify` - Verify magic link (signed route)

#### 4.1.4 Security Features

- **Suspended users** cannot log in via either method
- **Magic link tokens** expire after 15 minutes
- **Magic link tokens** are single-use (marked as used after verification)
- **Rate limiting** on magic link requests
- **Signed URLs** for magic link verification (prevents tampering)

#### 4.1.5 User Suspension

Users can be suspended by admins:
- `suspended_at` timestamp on users table
- Suspended users cannot authenticate
- Suspended users are silently blocked (no enumeration)

### 4.2 Admin System

The admin system provides user management and administrative controls.

#### 4.2.1 Admin Access Control

**Backend Protection:**
- `app/Domain/Admin/Middleware/EnsureUserIsAdmin.php` - Middleware
- Applied to all admin routes via `admin` middleware alias
- Checks `is_admin` boolean flag on User model

**Frontend Protection:**
- Admin navigation only visible to admin users
- Admin routes return 403 if accessed by non-admins

#### 4.2.2 Admin Features

**Admin Dashboard (`/admin`):**
- Overview page with user metrics
- Total users count
- Admin users count
- Recent signups

**User Management (`/admin/users`):**
- Paginated user list with search
- User detail view
- Edit user information (name, email)
- Toggle admin status (with last admin protection)
- Suspend/unsuspend users

#### 4.2.3 Key Files

**Backend:**
- `app/Domain/Admin/Controllers/AdminController.php` - Dashboard
- `app/Domain/Admin/Controllers/UserController.php` - User management
- `app/Domain/Admin/Middleware/EnsureUserIsAdmin.php` - Access control
- `app/Domain/Admin/Requests/UpdateUserRequest.php` - Validation

**Frontend:**
- `resources/js/domains/admin/pages/index.tsx` - Admin dashboard
- `resources/js/domains/admin/pages/users/index.tsx` - User list
- `resources/js/domains/admin/pages/users/show.tsx` - User detail

**Routes:**
- `GET /admin` - Admin dashboard
- `GET /admin/users` - User list
- `GET /admin/users/{user}` - User detail
- `PATCH /admin/users/{user}` - Update user
- `POST /admin/users/{user}/suspend` - Suspend user
- `POST /admin/users/{user}/unsuspend` - Unsuspend user

#### 4.2.4 Creating Admin Users

**Via Seeder:**
```bash
docker compose exec app php artisan db:seed --class=AdminUserSeeder
```

**Via Tinker:**
```php
$user = App\Domain\Users\Models\User::where('email', 'admin@example.com')->first();
$user->is_admin = true;
$user->save();
```

### 4.3 Billing & Subscriptions

The billing system implements a **hybrid monetization model**:
- **Subscription plans** (via Stripe) - Monthly recurring revenue
- **Credit system** - Metered usage for AI-heavy features
- **Feature gating** - Based on plan + credits

#### 4.3.1 Plan System

Plans are defined in `config/plans.php`:

```php
'plans' => [
    'free' => [
        'key' => 'free',
        'name' => 'Free',
        'type' => 'free',
        'monthly_credits' => 0,
        'features' => ['basic_usage'],
    ],
    'pro' => [
        'key' => 'pro',
        'name' => 'Pro',
        'type' => 'paid',
        'stripe_price_id' => env('STRIPE_PRICE_PRO_MONTHLY'),
        'monthly_credits' => 200,
        'features' => ['basic_usage', 'advanced_usage', 'priority'],
    ],
    // ...
]
```

**Plan Types:**
- `free` - No subscription required
- `paid` - Requires active Stripe subscription

**Features:**
- Array of feature keys that the plan enables
- Used for feature gating logic

#### 4.3.2 Subscription Lifecycle

**Start Subscription:**
1. User selects plan on billing page
2. System creates Stripe Checkout session
3. User completes payment on Stripe
4. Webhook updates subscription in database
5. User's `current_plan_key` is updated
6. Monthly credits are allocated

**Cancel Subscription:**
1. User cancels via billing portal or app
2. Subscription enters grace period
3. User retains access until period end
4. After expiration, plan reverts to `free`

**Change Plan:**
1. User selects new plan
2. Stripe subscription is updated
3. Plan change takes effect immediately (or at period end, depending on Stripe settings)

#### 4.3.3 Credit System

Credits are used for metered/AI-heavy operations.

**Credit Sources:**
1. **Monthly plan allocation** - Credits added monthly based on plan
2. **Credit pack purchases** - One-off purchases via Stripe
3. **Admin adjustments** - Manual adjustments (future)

**Credit Usage:**
- Before performing credit-costing action, check `$user->hasCredits($amount)`
- If insufficient, show credits paywall
- If sufficient, call `$user->chargeCredits($amount, $context)`
- Credits are tracked in `credit_transactions` table

**Key Methods (HasCredits trait):**
- `$user->creditsBalance()` - Get current balance
- `$user->hasCredits($amount)` - Check if user has enough
- `$user->addCredits($amount, $type, $description)` - Add credits
- `$user->chargeCredits($amount, $context)` - Deduct credits

#### 4.3.4 Feature Gating

Features are gated by:
1. **Plan** - User must be on a plan that includes the feature
2. **Credits** - User must have sufficient credits

**Backend Gating:**
```php
use App\Domain\Billing\Services\FeatureGateService;

$featureGate = app(FeatureGateService::class);

if (!$featureGate->canUseFeature($user, 'advanced_ai', 5)) {
    // Show paywall or return error
}
```

**Frontend Gating:**
```tsx
import { FeatureGate } from '@/domains/billing/components/FeatureGate';

<FeatureGate
    feature="advanced_ai"
    creditCost={5}
    requiredPlan="pro"
    fallback={<CreditsPaywall />}
>
    {/* Feature content */}
</FeatureGate>
```

#### 4.3.5 Paywall Components

Two reusable paywall components:

**PlanPaywall** (`resources/js/domains/billing/components/PlanPaywall.tsx`):
- Shown when user's plan doesn't include required feature
- Shows upgrade button

**CreditsPaywall** (`resources/js/domains/billing/components/CreditsPaywall.tsx`):
- Shown when user has insufficient credits
- Shows buy credits button

#### 4.3.6 Key Files

**Backend:**
- `app/Domain/Billing/Controllers/BillingController.php` - Billing actions
- `app/Domain/Billing/Controllers/CheckoutController.php` - Checkout handling
- `app/Domain/Billing/Controllers/StripeWebhookController.php` - Webhook handler
- `app/Domain/Billing/Services/PlanService.php` - Plan logic
- `app/Domain/Billing/Services/CreditService.php` - Credit logic
- `app/Domain/Billing/Services/FeatureGateService.php` - Feature gating
- `app/Domain/Billing/Traits/HasCredits.php` - Credit methods on User
- `app/Domain/Billing/Traits/HasSubscription.php` - Subscription methods on User
- `app/Domain/Billing/Models/CreditTransaction.php` - Transaction model

**Frontend:**
- `resources/js/domains/billing/components/PlanPaywall.tsx`
- `resources/js/domains/billing/components/CreditsPaywall.tsx`
- `resources/js/domains/billing/components/FeatureGate.tsx`
- `resources/js/domains/billing/components/CreditBalance.tsx`
- `resources/js/domains/settings/billing-settings.tsx` - Billing page

**Configuration:**
- `config/plans.php` - Plan and credit pack definitions

**Routes:**
- `POST /billing/checkout` - Create subscription checkout
- `POST /billing/portal` - Open Stripe billing portal
- `POST /billing/cancel` - Cancel subscription
- `POST /billing/credits/purchase` - Purchase credit pack
- `GET /billing/checkout/success` - Checkout success redirect
- `POST /stripe/webhook` - Stripe webhook endpoint

#### 4.3.7 Stripe Integration

**Laravel Cashier:**
- User model uses `Billable` trait from Cashier
- Handles Stripe customer creation
- Manages subscriptions via Cashier methods

**Webhooks:**
- All subscription events handled via webhook
- Webhook verifies Stripe signature
- Updates subscription status in database
- Allocates monthly credits on subscription creation/renewal

**Checkout Sessions:**
- Subscription checkout via Stripe Checkout
- Credit pack checkout via Stripe Checkout
- Metadata stored in session for processing

### 4.4 Settings System

The settings system provides user-configurable options.

#### 4.4.1 Settings Structure

Settings are organized into sections:
- **Profile** - Name, email (read-only)
- **Billing** - Subscription, credits, payment methods
- **Appearance** - Theme preferences (light/dark)

#### 4.4.2 Key Files

**Backend:**
- `app/Domain/Settings/Controllers/ProfileController.php` - Profile updates
- `app/Domain/Settings/Requests/ProfileUpdateRequest.php` - Validation

**Frontend:**
- `resources/js/domains/settings/profile-settings.tsx` - Profile settings
- `resources/js/domains/settings/billing-settings.tsx` - Billing settings
- `resources/js/domains/settings/appearance-settings.tsx` - Appearance settings

**Routes:**
- `PATCH /settings/profile` - Update profile
- `GET /settings/billing` - Get billing data

---

## 5. Database Schema

### 5.1 Core Tables

#### users
Primary user table with authentication and billing data.

**Columns:**
- `id` - Primary key
- `name` - User's name
- `email` - Unique email address (immutable)
- `email_verified_at` - Email verification timestamp
- `password` - Hashed password (not used for login, but required by Laravel)
- `is_admin` - Boolean admin flag
- `suspended_at` - Suspension timestamp (nullable)
- `credits_balance` - Current credit balance (integer)
- `current_plan_key` - Current plan identifier
- `stripe_id` - Stripe customer ID (from Cashier)
- `trial_ends_at` - Trial expiration (from Cashier)
- `two_factor_secret` - 2FA secret (not used, but column exists)
- `two_factor_recovery_codes` - 2FA recovery codes (not used)
- `two_factor_confirmed_at` - 2FA confirmation (not used)
- `remember_token` - Remember me token
- `created_at`, `updated_at` - Timestamps

**Relationships:**
- `hasMany` CreditTransaction
- `hasMany` Subscription (via Cashier)

#### subscriptions
Stripe subscription data (managed by Laravel Cashier).

**Columns:**
- `id` - Primary key
- `user_id` - Foreign key to users
- `type` - Subscription type
- `stripe_id` - Stripe subscription ID
- `stripe_status` - Subscription status (active, canceled, etc.)
- `stripe_price` - Stripe price ID
- `quantity` - Subscription quantity
- `trial_ends_at` - Trial expiration
- `ends_at` - Subscription end date
- `created_at`, `updated_at` - Timestamps

#### credit_transactions
Audit trail for credit additions and deductions.

**Columns:**
- `id` - Primary key
- `user_id` - Foreign key to users
- `amount` - Credit amount (positive for additions, negative for deductions)
- `type` - Transaction type (subscription, purchase, usage, admin_adjustment)
- `description` - Human-readable description
- `metadata` - JSON metadata (context, feature name, etc.)
- `created_at`, `updated_at` - Timestamps

**Indexes:**
- `user_id`
- `type`
- `created_at`

#### magic_link_tokens
Passwordless authentication tokens.

**Columns:**
- `id` - Primary key
- `email` - User email address
- `token` - Hashed token (SHA-256)
- `expires_at` - Token expiration timestamp
- `used_at` - Token usage timestamp (nullable)
- `created_at`, `updated_at` - Timestamps

**Indexes:**
- `email`
- `token` (unique)

### 5.2 Relationships

```
users
├── hasMany credit_transactions
├── hasMany subscriptions (via Cashier)
└── belongsToMany (teams - future)

credit_transactions
└── belongsTo user

subscriptions
└── belongsTo user

magic_link_tokens
└── (no relationship, email-based lookup)
```

### 5.3 Key Constraints

- **Email uniqueness:** Users must have unique emails
- **Email immutability:** Emails should not be changed (affects Stripe customer identity)
- **Credits non-negative:** Credits balance should never go negative (enforced in code)
- **Token single-use:** Magic link tokens are marked as used after verification

---

## 6. Development Guidelines

### 6.1 Code Organization Rules

#### Always Place Code in Domains

When adding new features:

1. **Identify the domain** - Which business domain does this belong to?
   - Auth, Admin, Users, Settings, Billing, Teams, etc.

2. **Place backend code** in `app/Domain/{Domain}/`
   - Controllers → `Controllers/`
   - Actions → `Actions/`
   - Services → `Services/`
   - Models → `Models/`
   - Requests → `Requests/`

3. **Place frontend code** in `resources/js/domains/{domain}/`
   - Pages → `pages/`
   - Components → `components/`

4. **Register routes** in appropriate route file
   - Admin routes → `routes/admin.php`
   - Billing routes → `routes/billing.php`
   - Settings routes → `routes/settings.php`
   - New domain → Create `routes/{domain}.php` and include in `web.php`

#### Naming Conventions

**Backend:**
- Controllers: `{Resource}Controller.php` (e.g., `UserController.php`)
- Actions: Verb + noun (e.g., `SendMagicLink.php`, `UpdateUserProfile.php`)
- Services: `{Domain}Service.php` (e.g., `PlanService.php`, `CreditService.php`)
- Models: Singular noun (e.g., `User.php`, `CreditTransaction.php`)
- Requests: `{Action}Request.php` (e.g., `UpdateUserRequest.php`)

**Frontend:**
- Pages: `{resource}.tsx` or `{resource}/{action}.tsx` (e.g., `index.tsx`, `users/show.tsx`)
- Components: PascalCase (e.g., `PlanPaywall.tsx`, `CreditBalance.tsx`)

### 6.2 UI/UX Guidelines

#### Design System

**Components:** Use shadcn/ui components exclusively
- Button, Card, Dialog, Input, Select, Table, etc.
- Located in `resources/js/components/ui/`

**Styling:** Tailwind CSS utility classes
- Use design tokens (colors, spacing, typography)
- Follow consistent spacing scale (gap-4, gap-6, p-4, p-6)
- Avoid random spacing values

**Icons:** Lucide React
- Standard size: 16-20px
- Use consistently across the app

#### Layout Pattern

Every dashboard page should follow this structure:

```
<AppLayout>
  <PageHeader>
    <Title />
    <Description />
    <Actions /> {/* Optional */}
  </PageHeader>
  
  <Content>
    <Card>
      {/* Page content */}
    </Card>
  </Content>
</AppLayout>
```

#### Component Patterns

**Forms:**
- Use shadcn Form components
- Label above input
- Error messages below input
- Consistent spacing

**Tables:**
- Use shadcn Table components
- Clear column headers
- Action column with dropdown menu
- Pagination at bottom

**Dialogs:**
- Use shadcn Dialog component
- Clear title and description
- Primary and secondary actions
- Consistent button placement

See `ui-guidelines.md` for detailed UI patterns.

### 6.3 Adding New Features

#### Step-by-Step: Adding a New Domain

**Example: Adding a "Notifications" domain**

1. **Create backend structure:**
   ```
   app/Domain/Notifications/
   ├── Controllers/
   │   └── NotificationController.php
   ├── Actions/
   │   └── SendNotification.php
   ├── Models/
   │   └── Notification.php
   └── Requests/
       └── CreateNotificationRequest.php
   ```

2. **Create frontend structure:**
   ```
   resources/js/domains/notifications/
   ├── pages/
   │   └── index.tsx
   └── components/
       └── NotificationList.tsx
   ```

3. **Create migration:**
   ```bash
   docker compose exec app php artisan make:migration create_notifications_table
   ```

4. **Create routes file:**
   ```
   routes/notifications.php
   ```
   Include in `routes/web.php`:
   ```php
   require __DIR__.'/notifications.php';
   ```

5. **Register routes:**
   ```php
   Route::middleware(['auth', 'verified'])
       ->prefix('notifications')
       ->name('notifications.')
       ->group(base_path('routes/notifications.php'));
   ```

6. **Add to navigation** (if needed):
   Update sidebar component to include notifications link

### 6.4 Best Practices

#### Security

**Always:**
- Validate input via Form Requests
- Authorize actions via Policies or middleware
- Never trust frontend-only checks
- Use parameterized queries (Eloquent handles this)
- Sanitize user input before display

**Authorization Pattern:**
```php
// In controller
$this->authorize('update', $user);

// Or in route
Route::middleware(['auth', 'admin'])->group(function () {
    // Admin routes
});
```

#### Error Handling

**Backend:**
- Use try-catch for external API calls (Stripe, Google OAuth)
- Return user-friendly error messages
- Log errors for debugging
- Use appropriate HTTP status codes

**Frontend:**
- Show user-friendly error messages
- Use Inertia's error handling
- Provide loading states
- Handle edge cases gracefully

#### Performance

**Database:**
- Use eager loading to avoid N+1 queries
- Add indexes for frequently queried columns
- Use pagination for large datasets

**Frontend:**
- Lazy load heavy components
- Use React.memo for expensive components
- Optimize images and assets

#### Code Quality

**Backend:**
- Use type hints and return types
- Follow PSR-12 coding standards
- Write self-documenting code
- Extract complex logic into Actions or Services

**Frontend:**
- Use TypeScript for type safety
- Extract reusable logic into hooks
- Keep components small and focused
- Use meaningful variable and function names

---

## 7. API & External Integrations

### 7.1 Stripe Integration

#### Setup

1. **Install Laravel Cashier:**
   ```bash
   composer require laravel/cashier
   ```

2. **Configure environment:**
   ```env
   STRIPE_KEY=pk_test_...
   STRIPE_SECRET=sk_test_...
   STRIPE_WEBHOOK_SECRET=whsec_...
   ```

3. **Publish Cashier migrations:**
   ```bash
   php artisan vendor:publish --tag="cashier-migrations"
   php artisan migrate
   ```

#### Usage

**User Model:**
```php
use Laravel\Cashier\Billable;

class User extends Authenticatable
{
    use Billable;
    // ...
}
```

**Create Checkout Session:**
```php
$checkoutSession = $stripe->checkout->sessions->create([
    'customer' => $user->stripe_id,
    'payment_method_types' => ['card'],
    'line_items' => [[
        'price' => $plan['stripe_price_id'],
        'quantity' => 1,
    ]],
    'mode' => 'subscription',
    'success_url' => route('billing.checkout.success'),
    'cancel_url' => route('dashboard'),
]);
```

**Webhook Handling:**
- Endpoint: `POST /stripe/webhook`
- Verifies Stripe signature
- Handles subscription events (created, updated, canceled, etc.)
- Updates database accordingly

**Key Files:**
- `app/Domain/Billing/Controllers/StripeWebhookController.php` - Webhook handler
- `app/Domain/Billing/Controllers/BillingController.php` - Checkout creation
- `app/Domain/Billing/Controllers/CheckoutController.php` - Checkout callbacks

### 7.2 Google OAuth Integration

#### Setup

1. **Install Laravel Socialite:**
   ```bash
   composer require laravel/socialite
   ```

2. **Configure environment:**
   ```env
   GOOGLE_CLIENT_ID=...
   GOOGLE_CLIENT_SECRET=...
   GOOGLE_REDIRECT_URI=http://localhost:8000/auth/google/callback
   ```

3. **Configure in `config/services.php`:**
   ```php
   'google' => [
       'client_id' => env('GOOGLE_CLIENT_ID'),
       'client_secret' => env('GOOGLE_CLIENT_SECRET'),
       'redirect' => env('GOOGLE_REDIRECT_URI'),
   ],
   ```

#### Usage

**Initiate OAuth:**
```php
return Socialite::driver('google')
    ->scopes(['openid', 'profile', 'email'])
    ->redirect();
```

**Handle Callback:**
```php
$googleUser = Socialite::driver('google')->user();
// Resolve or create user
// Log in user
```

**Key Files:**
- `app/Domain/Auth/Controllers/GoogleOAuthController.php` - OAuth controller
- `app/Domain/Auth/Actions/ResolveUserFromGoogle.php` - User resolution

### 7.3 Email (Magic Link)

Magic links are sent via Laravel's Mail system.

**Configuration:**
- Set in `.env` (see Development Environment Setup)
- Uses Laravel's built-in mail drivers

**Key Files:**
- `app/Domain/Auth/Actions/SendMagicLink.php` - Email sending
- `resources/views/emails/magic-link.blade.php` - Email template

---

## 8. Testing

### 8.1 Test Structure

Tests are organized by domain (following domain-driven structure):

```
tests/
├── Feature/
│   ├── Auth/          # Auth feature tests
│   ├── Settings/      # Settings feature tests
│   └── DashboardTest.php
└── Unit/
    └── ExampleTest.php
```

### 8.2 Running Tests

```bash
docker compose exec app php artisan test
```

**Run specific test:**
```bash
docker compose exec app php artisan test --filter TestName
```

**Run tests for specific domain:**
```bash
docker compose exec app php artisan test tests/Feature/Auth
```

### 8.3 Writing Tests

**Feature Test Example:**
```php
use Tests\TestCase;
use App\Domain\Users\Models\User;

class AuthTest extends TestCase
{
    public function test_user_can_login_with_magic_link(): void
    {
        $user = User::factory()->create();
        
        // Test magic link flow
        // ...
    }
}
```

---

## 9. Deployment & Production

### 9.1 Production Considerations

#### Environment Variables

Ensure all production environment variables are set:
- `APP_ENV=production`
- `APP_DEBUG=false`
- `APP_URL=https://yourdomain.com`
- Database credentials
- Stripe keys (production)
- Google OAuth credentials (production)
- Mail configuration

#### Stripe Webhook Configuration

1. Create webhook endpoint in Stripe Dashboard
2. Set URL: `https://yourdomain.com/stripe/webhook`
3. Select events to listen for:
   - `customer.subscription.created`
   - `customer.subscription.updated`
   - `customer.subscription.deleted`
   - `checkout.session.completed`
   - `invoice.payment_succeeded`
4. Copy webhook secret to `STRIPE_WEBHOOK_SECRET`

#### Google OAuth Production

1. Update OAuth redirect URI in Google Cloud Console:
   - `https://yourdomain.com/auth/google/callback`
2. Update `.env`:
   ```env
   GOOGLE_REDIRECT_URI=https://yourdomain.com/auth/google/callback
   ```

#### Database Migrations

Run migrations in production:
```bash
php artisan migrate --force
```

#### Asset Compilation

Build frontend assets:
```bash
npm run build
```

#### Queue Workers

If using queues, ensure queue workers are running:
```bash
php artisan queue:work
```

### 9.2 Monthly Credit Reset

**Note:** A scheduled command for monthly credit allocation is needed for production.

Create an Artisan command that:
1. Runs monthly (via Laravel scheduler)
2. Finds all users with active subscriptions
3. Allocates monthly credits based on their plan
4. Records transactions

Example:
```php
// In app/Console/Commands/AllocateMonthlyCredits.php
public function handle()
{
    User::whereHas('subscription', function ($query) {
        $query->where('stripe_status', 'active');
    })->each(function ($user) {
        $plan = $user->currentPlan();
        if ($plan && $plan['monthly_credits'] > 0) {
            $user->addCredits(
                $plan['monthly_credits'],
                'subscription',
                "Monthly allocation for {$plan['name']} plan"
            );
        }
    });
}
```

Schedule in `app/Console/Kernel.php`:
```php
protected function schedule(Schedule $schedule)
{
    $schedule->command('credits:allocate-monthly')
        ->monthly()
        ->onDay(1)
        ->at('00:00');
}
```

---

## 10. For Coding Agents

This section is specifically designed to help AI coding agents understand and work with this codebase.

### 10.1 System Understanding Guide

#### Core Architecture Principles

1. **Domain-Driven Structure**
   - All code is organized by business domain, not technical layer
   - Each domain is self-contained (backend + frontend together)
   - When adding features, identify the domain first

2. **Inertia.js Pattern**
   - Backend controllers return Inertia responses (not JSON APIs)
   - Frontend pages receive data as props
   - Navigation happens via Inertia router (client-side)
   - Forms submit via Inertia (no fetch/axios needed)

3. **Authentication Model**
   - Only Google OAuth and Magic Link (no passwords, no 2FA)
   - Auto-create users on first login
   - One email = one user account

4. **Billing Model**
   - User-based (not team-based)
   - Hybrid: subscriptions + credits
   - Plans defined in config, not database
   - Feature gating: plan + credits

#### How to Navigate the Codebase

**Finding Backend Code:**
1. Identify the domain (Auth, Admin, Billing, etc.)
2. Look in `app/Domain/{Domain}/`
3. Controllers handle HTTP, Actions contain business logic, Services are reusable

**Finding Frontend Code:**
1. Identify the domain
2. Look in `resources/js/domains/{domain}/`
3. Pages are route handlers, Components are reusable UI

**Finding Routes:**
- Main routes: `routes/web.php`
- Domain routes: `routes/{domain}.php` (admin.php, billing.php, settings.php)

**Finding Configuration:**
- Plans: `config/plans.php`
- App: `config/app.php`
- Services: `config/services.php`

### 10.2 Common Patterns

#### Adding a New Feature

1. **Identify domain** - Which domain does this belong to?
2. **Create backend structure:**
   - Controller in `app/Domain/{Domain}/Controllers/`
   - Actions in `app/Domain/{Domain}/Actions/` (if needed)
   - Service in `app/Domain/{Domain}/Services/` (if reusable logic)
   - Model in `app/Domain/{Domain}/Models/` (if new entity)
   - Request in `app/Domain/{Domain}/Requests/` (for validation)
3. **Create frontend structure:**
   - Page in `resources/js/domains/{domain}/pages/`
   - Components in `resources/js/domains/{domain}/components/`
4. **Register routes:**
   - Create or update `routes/{domain}.php`
   - Include in `routes/web.php` if new domain
5. **Add to navigation** (if needed)

#### Modifying Existing Features

1. **Find the domain** - Where does this feature live?
2. **Locate relevant files:**
   - Backend: `app/Domain/{Domain}/`
   - Frontend: `resources/js/domains/{domain}/`
3. **Make changes** following existing patterns
4. **Update tests** if applicable

#### Authentication Flow

**Backend:**
- Google OAuth: `GoogleOAuthController` → `ResolveUserFromGoogle` action
- Magic Link: `MagicLinkController` → `SendMagicLink` / `VerifyMagicLink` actions

**Frontend:**
- Login page: `resources/js/domains/auth/pages/login.tsx`
- Components: `GoogleLoginButton`, `MagicLinkForm`

#### Billing Flow

**Subscription:**
1. User selects plan → `BillingController::createCheckoutSession()`
2. Stripe Checkout → Webhook → `StripeWebhookController::handleWebhook()`
3. Database updated → User redirected to success page

**Credits:**
1. User purchases credits → `BillingController::purchaseCredits()`
2. Stripe Checkout → Webhook → Credits added via `CreditService`
3. Transaction recorded in `credit_transactions` table

**Feature Gating:**
- Backend: `FeatureGateService::canUseFeature()`
- Frontend: `<FeatureGate>` component with paywall fallbacks

### 10.3 Decision-Making Guidelines

#### When Adding Code, Ask:

1. **Which domain?** - Always place code in the correct domain
2. **Backend or frontend?** - Place in appropriate location within domain
3. **New feature or modification?** - Follow existing patterns
4. **Shared or domain-specific?** - Shared code goes in global folders
5. **Security?** - Always validate and authorize on backend

#### Code Placement Rules:

- ✅ Domain-specific controllers → `app/Domain/{Domain}/Controllers/`
- ✅ Domain-specific models → `app/Domain/{Domain}/Models/`
- ✅ Domain-specific UI → `resources/js/domains/{domain}/`
- ❌ Don't use `app/Http/Controllers/` for domain code
- ❌ Don't use `app/Models/` for domain models
- ❌ Don't use `resources/js/pages/` for domain pages

#### UI Guidelines:

- ✅ Use shadcn/ui components
- ✅ Follow layout pattern (sidebar + header + content)
- ✅ Use Tailwind utility classes
- ✅ Use Lucide icons
- ❌ Don't introduce new design systems
- ❌ Don't use random spacing values
- ❌ Don't create custom components when shadcn exists

### 10.4 Key Files Reference

**Authentication:**
- `app/Domain/Auth/Controllers/GoogleOAuthController.php`
- `app/Domain/Auth/Controllers/MagicLinkController.php`
- `app/Domain/Auth/Actions/ResolveUserFromGoogle.php`
- `app/Domain/Auth/Actions/SendMagicLink.php`
- `app/Domain/Auth/Actions/VerifyMagicLink.php`

**Admin:**
- `app/Domain/Admin/Controllers/AdminController.php`
- `app/Domain/Admin/Controllers/UserController.php`
- `app/Domain/Admin/Middleware/EnsureUserIsAdmin.php`

**Billing:**
- `app/Domain/Billing/Controllers/BillingController.php`
- `app/Domain/Billing/Controllers/StripeWebhookController.php`
- `app/Domain/Billing/Services/PlanService.php`
- `app/Domain/Billing/Services/CreditService.php`
- `app/Domain/Billing/Traits/HasCredits.php`
- `app/Domain/Billing/Traits/HasSubscription.php`

**User Model:**
- `app/Domain/Users/Models/User.php`

**Configuration:**
- `config/plans.php` - Plans and credit packs
- `config/fortify.php` - Authentication config
- `config/inertia.php` - Inertia config

**Routes:**
- `routes/web.php` - Main routes
- `routes/admin.php` - Admin routes
- `routes/billing.php` - Billing routes
- `routes/settings.php` - Settings routes

**Frontend Entry:**
- `resources/js/app.tsx` - Inertia app setup
- `resources/js/ssr.tsx` - SSR setup

### 10.5 Common Tasks

#### Adding a New Admin Feature

1. Create controller in `app/Domain/Admin/Controllers/`
2. Add route to `routes/admin.php` (already protected by admin middleware)
3. Create frontend page in `resources/js/domains/admin/pages/`
4. Add navigation link if needed

#### Adding a New Billing Plan

1. Add plan definition to `config/plans.php`
2. Create Stripe product and price
3. Add price ID to `.env`
4. Update billing UI to show new plan

#### Adding Feature Gating

1. Add feature key to plan's `features` array in `config/plans.php`
2. Use `FeatureGateService` in backend
3. Use `<FeatureGate>` component in frontend
4. Provide appropriate paywall fallback

#### Adding a New Domain

1. Create backend structure: `app/Domain/{Domain}/`
2. Create frontend structure: `resources/js/domains/{domain}/`
3. Create routes file: `routes/{domain}.php`
4. Include routes in `routes/web.php`
5. Add navigation if needed

### 10.6 Important Notes

- **Email addresses are immutable** - Don't allow email changes (affects Stripe customer identity)
- **Credits never go negative** - Always check before deducting
- **One email = one user** - Both auth methods use email as identifier
- **Plans are config-driven** - Don't store plans in database
- **Domain-driven structure is mandatory** - Always place code in correct domain
- **shadcn/ui only** - Don't introduce other component libraries
- **Backend authorization required** - Never rely on frontend-only checks

### 10.7 Reference Documents

- `specs.md` - Complete project specifications and requirements
- `ui-guidelines.md` - Detailed UI/UX guidelines
- `README.md` - Quick start guide

---

## Conclusion

This documentation provides a comprehensive guide to understanding and working with the Laravel + React Starter Kit application. For coding agents, focus on:

1. **Domain-driven structure** - Always place code in the correct domain
2. **Existing patterns** - Follow established patterns when adding features
3. **Security** - Always validate and authorize on the backend
4. **UI consistency** - Use shadcn/ui components and follow design guidelines
5. **Reference files** - Use the key files reference to navigate quickly

When in doubt, refer to `specs.md` for requirements and `ui-guidelines.md` for UI patterns.

